# 인덱스

## 8.1 디스크 읽기 방식
- 디스크 읽기 방식에는 랜덤 I/O, 순차 I/O가 있다.
- 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 핵심이다.

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
- CPU, MEMORY는 전자식 장치지만 하드 디스크 드라이브는 기계식 장치이다. 따라서 이는 항상 병목이 된다.
  - 따라서 하드 디스크 드라이브에서 데이터 저장용 원판을 제거하고 플래시 메모리를 장착한 SSD를 사용하게 되었다.
  - 플래시 메모리는 전원이 차단되도 데이터가 삭제되지 않는다.
  - 컴퓨터의 메모리 D-Ram보다는 느리지만 HDD보다는 빠르다.
  - 컴퓨터 메모리와 HDD는 10만배 이상 성능 차이가 있다. SSD는 천배의 차이를 보인다.
- 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 HDD보다 조금 더 빠르거나 비슷하다.
  - 하지만 데이터베이스에서 순차 I/O 작업은 비중이 그다지 크지 않다.
  - 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이다.
  - 랜덤 I/O 작업은 SSD가 HDD보다 훨씬 유리하다.

### 8.1.2 랜덤 I/O와 순차 I/O
- 랜덤과 순차 모두 동작 방식은 HDD의 원판을 돌려서 지정된 위치로 디스크 헤더를 위치 시킨 후 작업을 하는 것이다.
- 하지만 데이터 기록을 한다고 했을 때, 3개의 페이지를 기록 한다면 순차는 1번, 랜덤은 총 3번의 시스템 콜을 요청한다.
  - 즉 랜덤 I/O가 순차 I/O보다 3배 정도 느리다.
- 원판이 없는 SSD도 비슷한 성능 차이를 보인다.
- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 줄일 수 있는 방법은 그다지 많지 않고, 일반적으로 랜덤 I/O 자체를 줄이는 것이 목적이다.
  - **이는 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.**

## 8.2 인덱스란?
<details>
  <summary>Click to expand</summary>

  - 책의 색인과 같다
    - 값의 주소와 실제 데이터를 key - value 쌍으로 저장한다.
    - 색인이므로 정렬되어 있다. 주어진 순서대로 미리 정렬해서 보관한다.
  - 인덱스는 SortedList 자료구조와 같이 저장되는 칼럼의 값을 이용해서 항상 정렬된 상태를 유지한다.
  - 데이터 파일은 ArrayList와 같이저장된 순서대로 별도의 정렬없이 그대로 저장한다.
  - 저장하는 과정이 복잡하고 느리지만 이미 정렬되어 있으니 아주 빨리 원하는 값을 가져올 수 있다.
    - INSERT, UPDATE, DELETE 는 느려지고 인덱스를 갖고 있는 SELECT문은 아주 빨라진다.
  - 인덱스를 추가한다는 것은 아래의 사항을 고려해야한다.
    - 저장 속도를 어디까지 희생할 수 있는지
    - 읽기 속도를 얼마나 더 빠르게 만들어야 하는지
  - 인덱스의 분류
    - 역할별 구분
      - 프라이머리 키
      - 보조 키
    - 저장방식 구분
      - B-Tree
      - Hash
    - 중복여부 구분
      - Unique
      - Non-Unique
    - 기능별 구분
      - 전문 검색용 인덱스
      - 공간 검색용 인덱스
      - ...
</details>


## 8.3 B-Tree 인덱스
- Balanced Tree의 약자
- 원래 값을 변형 시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태를 유지한다.
- 특수한 경우를 제외하고 인덱스는 대부분 B-Tree이다

### 8.3.1 구조 및 특성
- Root Node
  - 자식 노드의 주소를 갖고 있다.
- Branch Node
  - 자식 노드의 주소를 갖고 있더ㅏ,
- Leaf Node
  - 실제 데이터 레코드를 찾아가기 위한 주소값(프라이머리키)을 갖고 있다