# 인덱스

## 8.1 디스크 읽기 방식
- 디스크 읽기 방식에는 랜덤 I/O, 순차 I/O가 있다.
- 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 핵심이다.

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
- CPU, MEMORY는 전자식 장치지만 하드 디스크 드라이브는 기계식 장치이다. 따라서 이는 항상 병목이 된다.
  - 따라서 하드 디스크 드라이브에서 데이터 저장용 원판을 제거하고 플래시 메모리를 장착한 SSD를 사용하게 되었다.
  - 플래시 메모리는 전원이 차단되도 데이터가 삭제되지 않는다.
  - 컴퓨터의 메모리 D-Ram보다는 느리지만 HDD보다는 빠르다.
  - 컴퓨터 메모리와 HDD는 10만배 이상 성능 차이가 있다. SSD는 천배의 차이를 보인다.
- 디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 HDD보다 조금 더 빠르거나 비슷하다.
  - 하지만 데이터베이스에서 순차 I/O 작업은 비중이 그다지 크지 않다.
  - 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이다.
  - 랜덤 I/O 작업은 SSD가 HDD보다 훨씬 유리하다.

### 8.1.2 랜덤 I/O와 순차 I/O
- 랜덤과 순차 모두 동작 방식은 HDD의 원판을 돌려서 지정된 위치로 디스크 헤더를 위치 시킨 후 작업을 하는 것이다.
- 하지만 데이터 기록을 한다고 했을 때, 3개의 페이지를 기록 한다면 순차는 1번, 랜덤은 총 3번의 시스템 콜을 요청한다.
  - 즉 랜덤 I/O가 순차 I/O보다 3배 정도 느리다.
- 원판이 없는 SSD도 비슷한 성능 차이를 보인다.
- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 줄일 수 있는 방법은 그다지 많지 않고, 일반적으로 랜덤 I/O 자체를 줄이는 것이 목적이다.
  - **이는 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.**

## 8.2 인덱스란?
<details>
  <summary>내용</summary>

  - 책의 색인과 같다
    - 값의 주소와 실제 데이터를 key - value 쌍으로 저장한다.
    - 색인이므로 정렬되어 있다. 주어진 순서대로 미리 정렬해서 보관한다.
  - 인덱스는 SortedList 자료구조와 같이 저장되는 칼럼의 값을 이용해서 항상 정렬된 상태를 유지한다.
  - 데이터 파일은 ArrayList와 같이저장된 순서대로 별도의 정렬없이 그대로 저장한다.
  - 저장하는 과정이 복잡하고 느리지만 이미 정렬되어 있으니 아주 빨리 원하는 값을 가져올 수 있다.
    - INSERT, UPDATE, DELETE 는 느려지고 인덱스를 갖고 있는 SELECT문은 아주 빨라진다.
  - 인덱스를 추가한다는 것은 아래의 사항을 고려해야한다.
    - 저장 속도를 어디까지 희생할 수 있는지
    - 읽기 속도를 얼마나 더 빠르게 만들어야 하는지
  - 인덱스의 분류
    - 역할별 구분
      - 프라이머리 키
      - 보조 키
    - 저장방식 구분
      - B-Tree
      - Hash
    - 중복여부 구분
      - Unique
      - Non-Unique
    - 기능별 구분
      - 전문 검색용 인덱스
      - 공간 검색용 인덱스
      - ...
</details>

## 8.3 B-Tree 인덱스
- Balanced Tree의 약자
- 원래 값을 변형 시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태를 유지한다.
- 특수한 경우를 제외하고 인덱스는 대부분 B-Tree이다

### 8.3.1 구조 및 특성
- Root Node
  - 자식 노드의 주소를 갖고 있다.
- Branch Node
  - 자식 노드의 주소를 갖고 있다.
- Leaf Node
  - 실제 데이터 레코드를 찾아가기 위한 주소값(프라이머리키)을 갖고 있다
- 인덱스의 키 값은 정렬되어 있지만 데이터 파일의 레코드는 정렬되어 있지 않다
  - 삭제나 변경이 전혀 없다면 순서대로 되어 있지만 삭제나 변경이 생겨 구멍이 생기면 DBMS가 그곳을 재활용하기 때문에 순차저장이라고 볼 수 는 없다.
- 인덱스는 테이블의 키 칼럼만 갖고 있으므로, 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아와야한다.
  - 여기서 랜덤 I/O 발생
  - 세컨더리 인덱스를 사용하는 경우
    - MYIsam 스토리지 엔진은 프라이머리키가 ROWID 이므로 인덱스가 레코드의 물리적인 주소를 갖는다.
      - 그래서 바로 인덱스 키값으로 바로 참조 가능하다.
    - InnoDB는 프라이머리키를 주소처럼 사용하므로 논리적인 주소를 갖는다.
      - 인덱스에 저장된 프라이머리 키 값으로 프라이머리 키 인덱스를 한번 더 검색해야 데이터를 가져올 수 있다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 인덱스 키 추가 
- 저장될 값을 이용해 B-Tree 상에 저장될 곳을 찾는다. 위치가 결정되면 리프노드에 저장하는데 리프노드가 꽉차면 리프노드 분리가 필요하다.
  - 이때는 상위 브랜치 노드까지 처리 범위가 넓어진다. 그래서 비용이 많이 드는 것으로 알려져있다.
  - 대략적으로 디스크에 저장이 1이라고 치면 인덱스 저장은 1.5로 친다. 인덱스가 여러개면 1.5 * N 만큼 더 비용이 든다.
- 스토리지 엔진 별로 처리 시점이 다르다
  - MyIsam이나 Memory엔진은 즉시 추가된다
  - InnoDB는 프라이머리키나 유니크 인덱스의 경우는 중복 체크때문에 즉시 추가하고 아니라면 체인지 버퍼에 담아서 후처리한다.

### 8.3.2.2 인덱스 키 삭제
- 추가보다 간단하다. 해당하는 리프 노드를 찾아서 삭제 마킹한다.
- 삭제 마킹된 공간은 방치 혹은 재활용된다.
- 5.5 이상의 InnoDB엔진에서는 이 또한 버퍼링되어 처리 가능하다.

### 8.3.2.3 인덱스 키 변경
- 인덱스 상의 키 값만 변경은 불가하고 기존 키를 삭제 후 새로 추가하는 방식이다.

### 8.3.2.4 인덱스 키 검색
- B-Tree의 루트 -> 리프로 이동하며 트리탐색을 한다.
- Select뿐 아니라 Update, Delete 처리에서 레코드 검색 시에도 사용한다.
- B-Tree 검색은 100% 일치 혹은 값의 앞부분(left-most part)만 일치하는 경우에 사용가능하다.
  - <, > 부등호 조건에 사용 가능
  - 인덱스 구성 키 값의 뒷부분만 검색 하는 용도는 사용 불가능
  - 함수나 연산으로 인덱스 키 값의 변형을 하는 경우 사용 불가능
- Update, Delete 시 검색된 레코드를 잠근 후 작업을 하는데, 인덱스가 없다면 불필요하게 많은 레코드가 잠길 수 있다.
  - 테이블 전체가 잠길 수 도 있음.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
- B-Tree 인덱스는 구성하는 칼럼의 크기와 레코드의 건수, 유니크한 인덱스 키 값의 개수에 의해 검색이나 변경 작업의 성능이 달라진다.

### 8.3.3.1 인덱스 키 값의 크기
- InnoDb 엔진은 저장하는 데이터의 기본 단위를 페이지 또는 블락이라고 한다.
  - 모든 읽기 쓰기 작업의 최소 단위
  - 버퍼풀의 버퍼링 기본 단위
  - 루트, 브랜치, 리프 노드를 구분하는 단위
- B-Tree의 자식 노드 개수는 가변적이며 이는 페이지 크기와 키 값의 크기에 따라 결정된다.
  - InnoDB 데이터 페이지 기본 크기는 16KB
  - 인덱스는 인덱스 키 값과 자식노드주소로 이루어진다. 
  - 인덱스 키 값이 커질수록 하나의 인덱스 페이지(리프노드)에 저장할 수 있는 인덱스의 크기가 줄어든다.
  - 예를들어 인덱스 페이지에 저장할 수 있는 개수가 500이라고 가정할때 Select 쿼리가 500개 이상의 데이터를 조회한다면 2개의 페이지를 읽어야한다.
  - 하지만 인덱스 키 사이즈가 작아서 인덱스 페이지에 700개를 저장할 수 있다면 하나의 데이터 페이지만 조회하면 된다!
  - 인덱스를 캐시하는 InnoDB 버퍼풀도 인덱스 키 크기가 클수록 저장할 수 있는 개수가 줄어든다.

### 8.3.3.2 B-Tree의 깊이
- 깊이는 제어하기 어렵지만 기본적으로 5 뎁스 이상 깊어지는 경우는 흔치 않다.
- 3 Depth를 가정하면 보통 (인덱스 키 값이 16바이트라고 가정) 2억개(585 * 585 * 585)의 키값 저장 가능
- 인덱스 키 값이 32바이트로 늘어난다면 5천만(372 * 372 * 372)으로 확 줄어든다.

### 8.3.3.3 기수성(Cardinality)
- 전체 인덱스 키 값이 10000개 인데, 그중 유니크한 값이 10개라면 기수성은 1000
  - 중복된 값이 많아지면 기수성은 낮아지고 성능이 떨어진다.
  - 기수성이 높으면 선택도가 높아져 검색 대상이 줄어들고 성능이 향상된다.
  - 예를들어 1만건의 레코드가 있는 테이블에서
    - A : 인덱스의 유니크한 값이 10개인경우
      - 카디널리티는 (10000 / 10) 1000
    - B : 인덱스의 유니크한 값이 1000개 인 경우
      - 카디널리티는 (10000 / 1000) 10
    - 원하는 레코드가 1건이라고 가정하면 A의 경우 불필요한 999건을 읽었고 B는 불필요한 9건을 읽었다.

### 8.3.3.4 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않는 것보다 더 높은 비용이 든다.
  - 기수성이 낮은 인덱스거나, 세컨더리 인덱스여서 I/O가 2배로 늘어날 수 있기 때문에 이렇게 말한듯
- 옵티마이저는 인덱스를 통해 읽은 레코드의 건수가 전체 테이블의 20 - 25%를 넘어가면 인덱스 안쓰고 풀스캔을 선택한다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔
- 나머지 방법들 보다 빠르다.
- 한 건만 읽는 경우, 한 건 이상 읽는 경우 둘 다 합쳐서 인덱스 레인지 스캔으로 명명
- 검색해야 할 인덱스의 범위가 결정 되었을때 사용하는 방식
- 인덱스 레인지 스캔 과정
  - Index Seek : 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다
  - Index Scan : Index Seek에서 탐색된 위치부터 필요한 만킁 인덱스를 차례대로 읽는다.
  - Index Scan에서 읽은 인덱스 키와 레코드 주소로 랜덤 I/O를 통해 실제 레코드를 읽는다.
    - 조회 대상이 인덱스에 포함된 컬럼만 있지 않다면 해당 데이터의 주소로 랜덤 I/O가 N번 발생한다.
    - 조회 대상이 포함된 컬럼만 있다면 커버링 인덱스 

### 8.3.4.2 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용된다
  - 인덱스가 (A, B, C) 걸려 있는데 조건이 B, C로 되어 있는 경우
- 인덱스에 명시된 컬럼 만으로 처리할 수 없이 데이터 레코드를 추가로 읽어야하면 사용안함
- 인덱스 레인지 스캔보다는 느리지만 테이블 풀 스캔보다는 빠르다.

### 8.3.4.3 루스 인덱스 스캔
- 5.7 버전까지는 많이 제한적이고 8.0부터 본격적으로 다른 DBMS의 인덱스 스킵 스캔과 비슷하게 동작한다.
- 인덱스 레인지 스캔과 비슷하게 동작하지만 중간에 필요치 않은 인덱스는 무시하는 방식
- GROUP BY, MIN, MAX 최적화에 사용된다.
```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dep_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```
- (dept_no, emp_no) 조합으로 인덱스가 만들어져 있고 정렬도 되어 있어서 dept_no 그룹별로 최초 값만 읽으면 된다. 이때 루스 인덱스 스캔이 사용된다.

### 8.3.4.4 인덱스 스킵 스캔
- 루스 인덱스 스캔과 비슷하지만, 전자는 GROUP BY 최적화에만 사용된다.
```sql
-- gender와 birth_date 칼럼에 인덱스 생성
ALTER TABLE employees
ADD INDEX IDX_EMPLOYEES_GENDER_BIRTHDATE (gender, birth_date);

-- 인덱스 효율적 사용 불가 쿼리
SELECT gender, birth_date 
FROM employees
WHERE birth_date >= '1965-02-01';

-- 인덱스 사용 가능 쿼리
SELECT gender, birth_date
FROM employees
WHERE gender = 'M' AND birth_date >= '1965-02-01';
```
- 인덱스 효율적 사용 불가 쿼리 explain을 하면 type에 index라고 나오는데 이는 인덱스 풀스캔을 의미한다.
  - 조회를 인덱스에 있는 컬럼만 사용해서 처리할 수 있기 때문!
- 8.0에 도입된 인덱스 스킵 스캡을 키면
```sql
SET optimizer_switch='skip_scan=ON';
```
- type에 range가 떠서 인덱스 레인지 스캔이 사용됨을 알 수 있다.
- 옵티마이저가 gender의 유니크한 값을 모두 조회해서 gender 칼럼의 조건을 추가해준다.
  - 내부적으로 아래 쿼리 2개를 날린것이다. 
```sql
SELECT gender, birth_date
FROM employees
WHERE gender = 'M' AND birth_date >= '1965-02-01';

SELECT gender, birth_date
FROM employees
WHERE gender = 'F' AND birth_date >= '1965-02-01'
```
- gender가 기수성이 낮아서 괜찮지만 높다면 그만큼 쿼리가 많이 생겨서 안좋겠지요? 

### 8.3.5 다중 칼럼 인덱스
- 다중 컬럼으로 인덱스를 생성하면 뒤의 컬럼은 앞의 컬럼에 의존해서 정렬 된다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스를 생성할 때 설정한 정렬 규칙에 따라 인덱스의 키 값은 ASC 혹은 DESC로 저장된다.
- ASC로 저장되도 뒤에서부터 읽으면 DESC로 사용가능하며 이는 옵티마이저가 실시간으로 판단한다.
- 5.7 까지는 다중 컬럼 인덱스 구성 시 각 컬럼별로 ASC, DESC를 지정할 수 없다.
  - 8.0부터는 혼합 인덱스로 설정 가능하다.

### 8.3.6.1.1 인덱스 스캔 방향
```sql
SELECT *
FROM employees
ORDER BY first_name DESC
LIMIT 1;
```
- 이 경우에 first_name 인덱스를 첨부터 읽어서 마지막거를 반환하지 않고 똑똑한 옵티마이저가 뒤에서부터 읽어서 1개만 가져온다.

### 8.3.6.1.2 내림차순 인덱스
- 내림차순 인덱스가 없는경우, 인덱스 정순 스캔은 역순 스캔보다 성능이 30%정도 높다.
  - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조를 갖는다.
  - 인덱스 페이지 내에서 인덱스들은 정순으로 단방향으로만 연결되어 있다.
```sql
SELECT *
FROM table
WHERE userid = ?
ORDER BY score DESC 
LIMIT 10;
```
- 위 쿼리의 경우
```sql
INDEX (userid ASC, score ASC);
INDEX (userid DESC, score DESC);
```
- 조회 모수가 적어서 2개 인덱스가 큰 차이가 없지만
- 빈번하게 많은 레코드가 역순으로 조회되어야한다면 역순 인덱스를 거는게 좋다