# Kafka

## 구성요소
- **토픽**
  - 카프카에서 데이터를 구분하기 위해 사용하는 단위.
  - 1개 이상의 파티션을 소유하고 있다.
- **파티션**
  - 프로듀서가 보낸 데이터들이 들어가서 저장됨. 이를 레코드라고 부른다.
  - 그룹으로 묶인 컨슈머들이 레코드를 병렬로 처리할 수 있도록 매칭된다.
  - 컨슈머 개수와 파티션 개수를 늘리면 처리량이 증가할 수 있다.
- **레코드**
  - 타임스팸트, 메세지 키, 메세지 값, 오프셋, 헤더 등으로 구성되어 있음
  - 프로듀서가 생성한 레코드가 브로커로 전송되면 오프셋과 타임스탬프가 지정되어 저장된다.
  - 적재된 레코드는 수정 불가하고 로그 리텐션 기간 또는 용량에 의해서만 삭제된다.
  - 매새지 키가 있으면 값을 해시해서 파티션을 지정한다.
    - 동일한 메세지 키는 동일한 파티션에 저장됨
    - null이면 라운드로빈으로 파티션에 분배된다.
- **브로커**
  - 카프카 클라이언트와 데이터를 주고받기 위해 사용하는 주체, 데이터를 분산 저장하여 fault tolerance를 갖는다. 
  - 한 서버에 한개의 브로커가 존재한다.
  - 1개도 가능하지만 안정성을 위해 3개 이상의 브로커를 하나의 클러스터로 묶어서 사용한다.
  - 여러개의 토픽을 갖는다.
  - 데이터는 파일 시스템에 저장되며, OS 레벨의 캐시를 사용해 IO 성능을 향상 시켰다.
  - log.segment.bytes, log.segment.ms 값을 통해 오래된 데이터를 삭제한다.
  - 오래된 데이터를 압축하는 정책을 설정할 수도 있다.
  - 컨슈머 오프셋 저장
    - 컨슈머 그룹이 토픽의 특정 파티션으로부터 데이터를 가져가서 처리한 결과를 확인하기 위해 오프셋을 커밋한다. 커밋한 오프셋은 
    _consumer_offsets__ 토픽에 저장한다.
  - **컨트롤러**
    - 클러스터의 다수 브로커중 한대가 컨트롤러 역할을 한다.
    - 다른 브로커들의 상태를 체크하고 장애 시 리터 파티션을 선출한다.
    - 컨트롤러에 장애가 생기면 다른 브로커가 대신한다.
  - **코디네이터**
    - 클러스터의 다수 브로커중 한대가 코디네이터 역할을 한다.
    - 컨슈머 그룹의 상태를 체크하고 파티션과 컨슈머가 매칭되도록 분배한다.
    - **리밸런싱**
      - 컨슈머가 컨슈머 그룹에서 빠지면 매칭되지 않은 파티션을 컨슈머로 재할당한다.
      - 컨슈머가 추가되는 상황에서도 발생 한다.
      - 컨슈머가 poll해서 가져온 데이터를 처리하는 중에 리밸런싱이 일어나면 데이터를 중복처리하게 된다. 커밋이 아직 안됐기 때문.
        - 리밸런스 리스너를 사용하면 리밸런스 이벤트를 받아서 마지막까지 처리한 레코드까지 커밋하도록 할 수 있다.
- **카프카 클러스터**
- **주키퍼**
  - 카프카의 메타데이터를 관리
- 컨슈머
  - poll() 메소드를 통해 브로커에서 메세지를 가져오고 처리를 한뒤 offset을 commit()한다.
  - 기본 옵션으로 일정 시간마다 자동으로 커밋을 수행하는데 이는 편리하지만 poll() 호출 이후에 리밸런싱
  또는 컨슈머 강제종료가 발생 시 컨슈머가 처리하는 데이터가 중복 또는 유실 될 수 있는 가능성이 있다. 따라서
  중복이나 유실을 허용하지 않는 서비스는 auto commit 하면 안된다.
  따라서 poll해서 가져온 데이터의 처리가 완료된 이후에 명시적으로 commitSync() 해야한다. 
  하지만 이는 동기적이라 성능 저하가 있어서 commitAsync() 사용가능. 하지만 중복 및 순서 보장 X 될 수 있음
  명시적으로 커밋하는 경우 enable_auto_commit_config를 false로 해야한다.
  - auto.offset.reset
    - earliest
      - 신규 애플리케이션이 처음 실행되거나 데이터를 처음부터 어픓리케이션에 대해 처리하는 경우
    - **latest**
      - 오직 최신 데이터를 분석하는 어플리케이션인 경우
    - none
      - 오프셋 유효성을 유지하고 싶다면. 예외 처리 필요
  - 어플리케이션 종료 시, shutdown hook을 받아서 컨슈머를 안전하게 종료해야한다.
  
## 데이터 복제
- 데이터 복제는 파티션 단위로 이뤄진다.
- 토픽 생성 시 파티션 복제 개수 설정 가능. 최대값은 브로커의 개수를 넘으면 안된다.
- 프로듀서, 컨슈머와 직접 통신하는 파티션을 리더, 나머지 복제 데이터를 가진 애들은 팔로워 파티션이다.
- 브로커가 다운되면 다른 브로커에 있는 팔로워 파티션이 리더가 된다.