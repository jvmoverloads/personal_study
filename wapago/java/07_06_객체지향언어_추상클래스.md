## 7.6 추상클래스

### 추상클래스란?
클래스가 설계도라면 추상클래스는 미완성 설계도에 비유할 수 있다. 클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성메서드(추상메서드)를
포함하고 있다는 의미이다.
미완성설계도로 완성된 제품을 만들 수 없듯, 추상클래스로 인스턴스를 생성할 수 없다. 
***추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.***<br>
<br>
추상클래스 자체로는 클래스로서의 역할을 다 못하지만, 조상클래스로서 중요한 의미를 갖는다. 새로운 클래스를 작성할 때 아무 것도 없는 상태에서 
시작하는 것보다는 어느 정도 틀을 갖춘 상태에서 시작하는 것이 나을 것이다.
실생활에서 보면, 같은 크기의 TV라도 기능의 차이에 따라 여러 종류의 모델이 있지만, 사실 이 둘의 설계도는 아마 90%정도는 동일할 것이다.
이들의 공통부분만을 그린 미완성설계도를 만들어 놓고, 각각의 설계도를 완성하는 것이 훨씬 효율적일 것이다.<br>
<br>
추상클래스는 키워드 'abstract'를 붙이기만 하면 된다. 이렇게 함으로써 이 클래스를 사용할 때, 클래스 선언부의 abstract를 보고 이 클래스에는
추상메서드가 있으니 상속을 통해서 구현해줘야 한다는 것을 쉽게 알 수 있다.
```java
abstract class 클래스이름 {
    // ......
}
```
추상클래스는 추상메서드를 포함하고 있다는 것을 제외하고는 일반클래스와 전혀 다르지 않다. 추상클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.

### 추상메서드
선언부만 작성하고 구현부는 작성하지 않고 남겨 놓은 메서드가 추상메서드이다. 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에
조상클래스에서는 선언부만을 작성하고, 실제 내용은 상속받는 클래스에서 구현하도록 비워 놓는다. 추상메서드는 구현부가 없으므로 괄호{ }대신
문장의 끝을 알리는 ';'을 적어준다.<br>
<br>
추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 한다. 만일 조상으로부터 상속받은
추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.

### 추상클래스의 작성
사옥이 자손클래스를 만드는 데 조상클래스를 사용하는 것이라면, 이와 반대로 추상화는 기존의 클래스의 공통부분을 뽑아내서 조상클래스를 만드는 것이라고
할 수 있다.
```java
abstract class Player {
    boolean pause;
    int currentPos;
    
    // 추상클래스도 생성자가 있어야 한다.
    Player() {  
        pause = false;
        currentPos = 0;
    }
    
    // 지정된 위치에서 재생을 시작하는 기능이 수행하도록 작성되어야 한다.
    abstract void play(int pos);
    // 재생을 즉시 멈추는 기능을 수행하도록 작성되어야 한다.
    abstract void stop();
    
    void play() {
        play(currentPos);
    }
    
    void pause() {
        if (pause) {
            pause = false;
            play(currentPos);
        } else {
            pause = true;
            stop();
        }
    }
}
```
Player클래스를 조상으로 하는 CDPlayer 클래스를 만들어보자.
```java
class CDPlayer extends Player {
    void play(int currentPos) {
        /* 조상의 추상메서드를 구현. */
    }
    
    void stop() {
        /* 조상의 추상메서드를 구현. */
    }
    
    // CDPlayer클래스에 추가로 정의된 멤버
    int currentTrack;
    
    void nextTrack() {
        currentTrack++;
        // .....
    }
    
    void preTrack() {
        if (currentTrack > 1) {
            currentTrack--;
            // .....
        }
    }
}
```
사실 Player클래스의 play(int pos)와 stop()을 추상메서드로 하는 대신, 아무 내용도 없는 메서드로 작성할 수도 있다. 아무 내용없이
단지 { }만 있어도, 추상메서드가 아닌 일반 메서드로 간주되기 때문이다. 어차피 자손클래스에서 오버라이딩하여 자신의 클래스에 맞게 구현할 테니 추상메서드로 
선언하는 것과 내용없는 빈 몸통만 만들어 놓는 것이나 별 차이가 없어 보인다.<br>
그래도 굳이 abstract를 붙여서 ***추상메서드로 선언하는 이유는 자손클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다.***<br>
이번엔 기존의 클래스로부터 공통된 부분을 뽑아내어 추상클래스를 만들어 보도록 하자.
```java
class Marine {
    int x, y;
    void move(int x, int y) { /* 지정된 위치로 이동 */ }
    void stop() { /* 현재 위치에 정지 */}
    void stimPack() { /* 스팀팩을 사용한다. */}
}

class Tank {
    int x, y;
    void move(int x, int y) { /* 지정된 위치로 이동 */}
    void stop() {/* 현재 위치에 정지 */}
    void changeMode() { /*공격모드를 변환한다. */}
}

class Dropship {
    int x, y;
    void move(int x, int y) { /* 지정된 위치로 이동 */}
    void stop() {/* 현재 위치에 정지 */}
    void load() { /* 선택된 대상을 태운다. */}
    void unload() { /*선택된 대상을 내린다. */}
}
```
공통부분을 뽑아내어 하나의 클래스로 만들고, 이 클래스로부터 상속받도록 변경해보자.
```java
abstract class Unit {
    int x, y;
    abstract void move(int x, int y);
    void stop() { /* 현재 위치에 정지 */}
}

class Marine extends Unit {
    void move(int x, int y) { /* 지정된 위치로 이동 */ }
    void stimPack() { /* 스팀팩을 사용한다. */}
}

class Tank extends Unit {
    void move(int x, int y) { /* 지정된 위치로 이동 */}
    void changeMode() { /*공격모드를 변환한다. */}
}

class Dropship extends Unit {
    void move(int x, int y) { /* 지정된 위치로 이동 */}
    void load() { /* 선택된 대상을 태운다. */}
    void unload() { /*선택된 대상을 내린다. */}
}
```