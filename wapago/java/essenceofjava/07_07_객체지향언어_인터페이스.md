## 7.7 인터페이스

### 인터페이스란?
일종의 추상클래스이다. 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘
***일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.*** ***오직 추상메서드와 상수만을 멤버로 갖는다.***

### 인터페이스의 작성
클래스를 작성하는 것과 같다. 다만 키워드로 class 대신 interface를 사용한다는 것만 다르다. interface에도 클래스와 같이 접근제어자로
public 또는 default를 사용할 수 있다.

    interface 인터페이스이름 {
        public static final 타입 상수이름 = 값;
        public abstract 메서드이름(매개변수목록);
    }

일반적인 클래스의 멤버들과 달리 인터페이스의 멤버들은 다음과 같은 제약사항이 있다.

    - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
    - 모든 메서드는 public abstract이어야 하며, 이를 생략할 수 있다.
      (단, static메서드와 디폴드 메서드는 예외. JDK 1.8부터)

인터페이스에 정의된 모든 멤버에 예외없이 적용되는 사항이어서 제어자를 생략할 수 있는 것이며, 편의상 생략하는 경우가 많다. 생략된 제어자는
컴파일 시에 컴파일러가 자동적으로 추가해준다.<br>
원래는 인터페이스의 모든 메서드는 추상메서드이어야 하는데, JDK1.8부터 인터페이스에 static메서드와 디폴트 메서드(default method)의 추가를 허용하는
방향으로 변경되었다. 실무에서는 아직 JDK1.8을 사용하지 않는 곳이 많기 때문에, JDK1.8이전의 규칙과 이후의 규칙을 모두 알고 있어야 한다.

### 인터페이스의 상속
인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.
```java
interface Movable {
    // 지정된 위치(x, y)로 이동하는 기능의 메서드
    void move(int x, int y);
}

interface Attackable {
    // 지정된 대상(u)을 공격하는 기능의 메서드
    void attack(Unit u);
}

interface Fightable extends Movable, Attackable { }
```
클래스의 상속과 마찬가지로 자손(Fightable)은 조상 인터페이스(Movable, Attackable)에 정의된 멤버를 모두 상속받는다. 그래서 Fightable자체에는
정의된 멤버가 하나도 없지만 조상 인터페이스로부터 상속받은 두 개의 추상메서드, move(int x, int y)와 attack(Unit u)을 멤버로 갖게 된다.

### 인터페이스의 구현
인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 추상클래스가 상속을 통해 추상메서드를 완성하는 것처럼, 인터페이스도 자신에 정의된
추상메서드의 몸통을 만들어주는 클래스를 작성해야 하는데, 그 방법은 추상클래스가 자신을 상속받는 클래스를 정의하는 것과 다르지 않다. 
extends 대신 implements를 사용한다.